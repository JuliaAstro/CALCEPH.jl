<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · CALCEPH.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CALCEPH.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>-</a><ul class="internal"></ul></li><li><a class="toctext" href="../constants/">-</a></li><li><a class="toctext" href="../context/">-</a></li><li><a class="toctext" href="../errors/">-</a></li><li><a class="toctext" href="../ids/">-</a></li><li><a class="toctext" href="../">Quick start</a></li><li><a class="toctext" href="../install/">Retrieving and installing CALCEPH.jl</a></li><li><a class="toctext" href="../introspection/">-</a></li><li><a class="toctext" href="../units/">-</a></li><li><a class="toctext" href="../utilities/">-</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>-</a></li></ul><a class="edit-page" href="https://github.com/bgodard/CALCEPH.jl/blob/master/docs/src/compute.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>-</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CALCEPH.compute" href="#CALCEPH.compute"><code>CALCEPH.compute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">compute(eph,jd0,time,target,center)</code></pre><p>Compute position and velocity of target with respect to center at epoch jd0+time. This method does not support the NAIF numbering scheme. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p>This method does not support the NAIF body identification scheme.</p><p>Output units are:</p><ul><li>AU and AU/day for position and velocity</li><li>rad and rad/day for librations</li><li>second and unitless for time ephemeris and time ephemeris rate</li></ul><p><strong>Arguments</strong></p><ul><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body or reference point whose coordinates are required.</li><li><code>center::Integer</code>: The origin of the coordinate system.</li></ul><p>The possible values for target and center are :</p><ul><li>1 : Mercury Barycenter</li><li>2 : Venus Barycenter</li><li>3 : Earth</li><li>4 : Mars Barycenter</li><li>5 : Jupiter Barycenter</li><li>6 : Saturn Barycenter</li><li>7 : Uranus Barycenter</li><li>8 : Neptune Barycenter</li><li>9 : Pluto Barycenter</li><li>10    : Moon</li><li>11    : Sun</li><li>12    : Solar Sytem barycenter</li><li>13    : Earth-moon barycenter</li><li>14    : Nutation angles</li><li>15    : Librations</li><li>16    : TT-TDB</li><li>17    : TCG-TCB</li><li>asteroid number + 2000000    : asteroid</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/compute.jl#L1-L45">source</a><div><div><pre><code class="language-none">compute(eph,jd0,time,target,center,unit)</code></pre><p>Compute position and velocity of target with respect to center at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body or reference point whose coordinates are required. The numbering system depends on the parameter unit.</li><li><code>center::Integer</code>: The origin of the coordinate system. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/compute.jl#L113-L131">source</a><div><div><pre><code class="language-none">compute(eph,jd0,time,target,center,unit,order)</code></pre><p>Compute position and derivatives up to order of target with respect to center at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body or reference point whose coordinates are required. The numbering system depends on the parameter unit.</li><li><code>center::Integer</code>: The origin of the coordinate system. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center.</li><li><code>order::Integer</code> : The order of derivatives<ul><li>0: only the position is computed.</li><li>1: only the position and velocity are computed.</li><li>2: only the position, velocity and acceleration are computed.</li><li>3: the position, velocity and acceleration and jerk are computed.</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/compute.jl#L173-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CALCEPH.unsafe_compute!" href="#CALCEPH.unsafe_compute!"><code>CALCEPH.unsafe_compute!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unsafe_compute!(eph,jd0,time,target,center)</code></pre><p>In place version of the compute function. Does not perform any checks! Compute position and velocity of target with respect to center at epoch jd0+time. This method does not support the NAIF numbering scheme. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p>This method does not support the NAIF body identification scheme.</p><p>Output units are:</p><ul><li>AU and AU/day for position and velocity</li><li>rad and rad/day for librations</li><li>second and unitless for time ephemeris and time ephemeris rate</li></ul><p><strong>Arguments</strong></p><ul><li><code>result</code>: container for result. It is not checked if it is sufficiently large enough!</li><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body or reference point whose coordinates are required.</li><li><code>center::Integer</code>: The origin of the coordinate system.</li></ul><p><strong>Return:</strong></p><ul><li>status integer from CALCEPH: 0 if an error occured</li></ul><p>The possible values for target and center are :</p><ul><li>1 : Mercury Barycenter</li><li>2 : Venus Barycenter</li><li>3 : Earth</li><li>4 : Mars Barycenter</li><li>5 : Jupiter Barycenter</li><li>6 : Saturn Barycenter</li><li>7 : Uranus Barycenter</li><li>8 : Neptune Barycenter</li><li>9 : Pluto Barycenter</li><li>10    : Moon</li><li>11    : Sun</li><li>12    : Solar Sytem barycenter</li><li>13    : Earth-moon barycenter</li><li>14    : Nutation angles</li><li>15    : Librations</li><li>16    : TT-TDB</li><li>17    : TCG-TCB</li><li>asteroid number + 2000000    : asteroid</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/compute.jl#L55-L104">source</a><div><div><pre><code class="language-none">unsafe_compute!(result,eph,jd0,time,target,center,unit)</code></pre><p>In place version of the compute function. Does not perform any checks! Compute position and velocity of target with respect to center at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: container for result. It is not checked if it is sufficiently large enough!</li><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body or reference point whose coordinates are required. The numbering system depends on the parameter unit.</li><li><code>center::Integer</code>: The origin of the coordinate system. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center.</li></ul><p><strong>Return:</strong></p><ul><li>status integer from CALCEPH: 0 if an error occured</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/compute.jl#L141-L164">source</a><div><div><pre><code class="language-none">unsafe_compute!(result,eph,jd0,time,target,center,unit,order)</code></pre><p>In place version of the compute function. Does not perform any checks! Compute position and derivatives up to order of target with respect to center at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: container for result. It is not checked if it is sufficiently large enough!</li><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body or reference point whose coordinates are required. The numbering system depends on the parameter unit.</li><li><code>center::Integer</code>: The origin of the coordinate system. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center.</li><li><code>order::Integer</code> : The order of derivatives<ul><li>0: only the position is computed.</li><li>1: only the position and velocity are computed.</li><li>2: only the position, velocity and acceleration are computed.</li><li>3: the position, velocity and acceleration and jerk are computed.</li></ul></li></ul><p><strong>Return:</strong></p><ul><li>status integer from CALCEPH: 0 if an error occured</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/compute.jl#L207-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CALCEPH.orient" href="#CALCEPH.orient"><code>CALCEPH.orient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">orient(eph,jd0,time,target,unit)</code></pre><p>Compute Euler angles and first derivative for the orientation of target at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body whose orientation is required. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). The angles are expressed in radians if unit contains unitRad. If the unit contains outputNutationAngles, the nutation angles are computed rather than the Euler angles.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/orient.jl#L1-L18">source</a><div><div><pre><code class="language-none">orient(eph,jd0,time,target,unit,order)</code></pre><p>Compute Euler angles and derivatives up to order for the orientation of target at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body whose orientation is required. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). If the unit contains outputNutationAngles, the nutation angles are computed rather than the Euler angles.</li><li><code>order::Integer</code> : The order of derivatives<ul><li>0: only the angles are computed.</li><li>1: only the angles and 1st derivatives are computed.</li><li>2: only the angles, the 1st derivatives and 2nd derivatives are computed.</li><li>3: the angles, the 1st derivatives, 2nd derivatives and 3rd derivatives are computed.</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/orient.jl#L59-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CALCEPH.unsafe_orient!" href="#CALCEPH.unsafe_orient!"><code>CALCEPH.unsafe_orient!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unsafe_orient!(result,eph,jd0,time,target,unit)</code></pre><p>In place version of the orient function. Does not perform any checks! Compute Euler angles and first derivative for the orientation of target at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: container for result. It is not checked if it is sufficiently large enough!</li><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body whose orientation is required. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). If the unit contains outputNutationAngles, the nutation angles are computed rather than the Euler angles.</li></ul><p><strong>Return:</strong></p><ul><li>status integer from CALCEPH: 0 if an error occured</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/orient.jl#L28-L50">source</a><div><div><pre><code class="language-none">unsafe_orient!(result,eph,jd0,time,target,unit,order)</code></pre><p>In place version of the orient function. Does not perform any checks! Compute Euler angles and derivatives up to order for the orientation of target at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><p><code>result</code>: container for result. It is not checked if it is sufficiently large enough!</p></li><li><p><code>eph</code>: ephemeris</p></li><li><p><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</p></li><li><p><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</p></li><li><p><code>target::Integer</code>: The body whose orientation is required. The numbering system depends on the parameter unit.</p></li><li><p><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). If the unit contains outputNutationAngles, the nutation angles are computed rather than the Euler angles.</p></li><li><p><code>order::Integer</code> : The order of derivatives</p><ul><li>0: only the angles are computed.</li><li>1: only the angles and 1st derivatives are computed.</li><li>2: only the angles, the 1st derivatives and 2nd derivatives are computed.</li><li>3: the angles, the 1st derivatives, 2nd derivatives and 3rd derivatives are computed.</li></ul><h1>Return:</h1><ul><li>status integer from CALCEPH: 0 if an error occured</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/orient.jl#L92-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CALCEPH.rotAngMom" href="#CALCEPH.rotAngMom"><code>CALCEPH.rotAngMom</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rotAngMom(eph,jd0,time,target,unit)</code></pre><p>Compute angular momentum due to rotation and first derivative of target at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body whose angular momentum is required. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). The angles are expressed in radians if unit contains unitRad.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/rotAngMom.jl#L1-L18">source</a><div><div><pre><code class="language-none">rotAngMom(eph,jd0,time,target,unit,order)</code></pre><p>Compute angular momentum due to rotation and derivatives up to order of target at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body whose angular momentum is required. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute).</li><li><code>order::Integer</code> : The order of derivatives<ul><li>0: only the angles are computed.</li><li>1: only the angles and 1st derivatives are computed.</li><li>2: only the angles, the 1st derivatives and 2nd derivatives are computed.</li><li>3: the angles, the 1st derivatives, 2nd derivatives and 3rd derivatives are computed.</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/rotAngMom.jl#L59-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CALCEPH.unsafe_rotAngMom!" href="#CALCEPH.unsafe_rotAngMom!"><code>CALCEPH.unsafe_rotAngMom!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unsafe_rotAngMom!(result,eph,jd0,time,target,unit)</code></pre><p>In place version of the rotAngMom function. Does not perform any checks! Compute angular momentum due to rotation and first derivative of target at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: container for result. It is not checked if it is sufficiently large enough!</li><li><code>eph</code>: ephemeris</li><li><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</li><li><code>target::Integer</code>: The body whose angular momentum is required. The numbering system depends on the parameter unit.</li><li><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). The angles are expressed in radians if unit contains unitRad.</li></ul><p><strong>Return:</strong></p><ul><li>status integer from CALCEPH: 0 if an error occured</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/rotAngMom.jl#L28-L50">source</a><div><div><pre><code class="language-none">unsafe_rotAngMom!(result,eph,jd0,time,target,unit,order)</code></pre><p>In place version of the rotAngMom function. Does not perform any checks! Compute angular momentum due to rotation and derivatives up to order of target at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don&#39;t take care about precision.</p><p><strong>Arguments</strong></p><ul><li><p><code>result</code>: container for result. It is not checked if it is sufficiently large enough!</p></li><li><p><code>eph</code>: ephemeris</p></li><li><p><code>jd0::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</p></li><li><p><code>time::Float64</code>: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)</p></li><li><p><code>target::Integer</code>: The body whose angular momentum is required. The numbering system depends on the parameter unit.</p></li><li><p><code>unit::Integer</code> : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute).</p></li><li><p><code>order::Integer</code> : The order of derivatives</p><ul><li>0: only the angles are computed.</li><li>1: only the angles and 1st derivatives are computed.</li><li>2: only the angles, the 1st derivatives and 2nd derivatives are computed.</li><li>3: the angles, the 1st derivatives, 2nd derivatives and 3rd derivatives are computed.</li></ul><h1>Return:</h1><ul><li>status integer from CALCEPH: 0 if an error occured</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bgodard/CALCEPH.jl/blob/1a6fc1dbf9c30ddce73642686cd9661af64bea43/src/rotAngMom.jl#L92-L119">source</a></section><footer><hr/><a class="next" href="../constants/"><span class="direction">Next</span><span class="title">-</span></a></footer></article></body></html>
