{
    "docs": [
        {
            "location": "/", 
            "text": "CALCEPH.jl is a julia wrapper for \nCALCEPH\n a C library for reading planetary ephemeris files, such INPOPxx, JPL DExxx and SPICE ephemeris files.\n\n\nCALCEPH\n C library is developped by \nIMCCE\n.\n\n\n\n\nQuick start\n\n\nIn your favorite Julia interpreter, run:\n\n\nPkg.clone(\nhttps://github.com/bgodard/CALCEPH.jl\n)\nusing CALCEPH\n\n# ephemeris kernels can be downloaded from many different sources\ndownload(\nftp://ftp.imcce.fr/pub/ephem/planets/inpop13c/inpop13c_TDB_m100_p100_tt.dat\n,\nplanets.dat\n)\n# WARNING this file is huge (Jupiter Moons ephemeris)\n# download(\nhttps://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/satellites/jup310.bsp\n,\njupiter_system.bsp\n)\n\n# create an ephemeris context\neph = CalcephEphem(\nplanets.dat\n)\n# from multiple files\n# eph = CalcephEphem([\nplanets.dat\n,\njupiter_system.bsp\n])\n\n# prefetch ephemeris files data to main memory for faster access\nCalcephPrefetch(eph)\n\n# retrieve constants from ephemeris as a dictionary\nconstants = CalcephConstants(eph)\n# list the constants\nkeys(constants)\n# get the sun J2\nJ2sun = constants[:J2SUN]\n\n# retrieve the position, velocity and acceleration of Earth (geocenter) relative\n# to the Earth-Moon system barycenter in kilometers, kilometers per second and\n# kilometers per second square at JD= 2451624.5 TDB timescale\n# for best accuracy the first time argument should be the integer part and the\n# delta the fractional part\n# when using NAIF identification numbers, CalcephUseNaifId has to be added to\n# the units argument.\npva=CalcephComputeOrder(eph,2451624.0,0.5,NaifId.id[:earth],NaifId.id[:emb],\n                        CalcephUseNaifId+CalcephUnitKM+CalcephUnitSec,2)\nposition=pva[1:3]\nvelocity=pva[4:6]\nacceleration=pva[7:end]\n\n# what is the NAIF identification number for Deimos\nid_deimos = NaifId.id[:deimos]\n\n# what does NAIF ID 0 correspond to?\nnames_0 = NaifId.names[0]\n\n\n\n\n\n\nWhy use CALCEPH?\n\n\nCALCEPH functionality is also provided by \nNAIF SPICE Toolkit\n. However CALCEPH has several advantages over SPICE:\n\n\n\n\nIt is faster at computing ephemeris data.\n\n\nIt can handle multiple ephemeris context whereas SPICE cannot.\n\n\nIt is thread safe (if using one context per thread) whereas SPICE is not.\n\n\nIt can compute higher order derivatives (acceleration and jerk) approximation using differentiation of the interpolation polynomials.\n\n\nIts ephemeris computation interface expects the time separated in two double precision numbers (SPICE interface only has one). This can be used to achieve higher\n\n\n\n\nprecision in timetag (this can have a significant impact when modeling Doppler observations from a deep space probe).\n\n\n\n\nIt is distributed as a single cross platform source making it easy to integrate in other projects whereas SPICE is distributed one source per platform.\n\n\n\n\nBut CALCEPH does not support all functions of the SPICE Toolkit. If you need more functionalities \nSPICE.jl\n is a Julia wrapper for SPICE.", 
            "title": "Quick start"
        }, 
        {
            "location": "/#quick-start", 
            "text": "In your favorite Julia interpreter, run:  Pkg.clone( https://github.com/bgodard/CALCEPH.jl )\nusing CALCEPH\n\n# ephemeris kernels can be downloaded from many different sources\ndownload( ftp://ftp.imcce.fr/pub/ephem/planets/inpop13c/inpop13c_TDB_m100_p100_tt.dat , planets.dat )\n# WARNING this file is huge (Jupiter Moons ephemeris)\n# download( https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/satellites/jup310.bsp , jupiter_system.bsp )\n\n# create an ephemeris context\neph = CalcephEphem( planets.dat )\n# from multiple files\n# eph = CalcephEphem([ planets.dat , jupiter_system.bsp ])\n\n# prefetch ephemeris files data to main memory for faster access\nCalcephPrefetch(eph)\n\n# retrieve constants from ephemeris as a dictionary\nconstants = CalcephConstants(eph)\n# list the constants\nkeys(constants)\n# get the sun J2\nJ2sun = constants[:J2SUN]\n\n# retrieve the position, velocity and acceleration of Earth (geocenter) relative\n# to the Earth-Moon system barycenter in kilometers, kilometers per second and\n# kilometers per second square at JD= 2451624.5 TDB timescale\n# for best accuracy the first time argument should be the integer part and the\n# delta the fractional part\n# when using NAIF identification numbers, CalcephUseNaifId has to be added to\n# the units argument.\npva=CalcephComputeOrder(eph,2451624.0,0.5,NaifId.id[:earth],NaifId.id[:emb],\n                        CalcephUseNaifId+CalcephUnitKM+CalcephUnitSec,2)\nposition=pva[1:3]\nvelocity=pva[4:6]\nacceleration=pva[7:end]\n\n# what is the NAIF identification number for Deimos\nid_deimos = NaifId.id[:deimos]\n\n# what does NAIF ID 0 correspond to?\nnames_0 = NaifId.names[0]", 
            "title": "Quick start"
        }, 
        {
            "location": "/#why-use-calceph", 
            "text": "CALCEPH functionality is also provided by  NAIF SPICE Toolkit . However CALCEPH has several advantages over SPICE:   It is faster at computing ephemeris data.  It can handle multiple ephemeris context whereas SPICE cannot.  It is thread safe (if using one context per thread) whereas SPICE is not.  It can compute higher order derivatives (acceleration and jerk) approximation using differentiation of the interpolation polynomials.  Its ephemeris computation interface expects the time separated in two double precision numbers (SPICE interface only has one). This can be used to achieve higher   precision in timetag (this can have a significant impact when modeling Doppler observations from a deep space probe).   It is distributed as a single cross platform source making it easy to integrate in other projects whereas SPICE is distributed one source per platform.   But CALCEPH does not support all functions of the SPICE Toolkit. If you need more functionalities  SPICE.jl  is a Julia wrapper for SPICE.", 
            "title": "Why use CALCEPH?"
        }, 
        {
            "location": "/install/", 
            "text": "Prerequisites\n\n\n\n\nLinux and OS X\n\n\nIf you do not have the \nCALCEPH C library\n installed, the installation process will fetch it and try to build it, in which case you need a working C compiler.\n\n\n\n\nWindows\n\n\nInstall first the \nCALCEPH C library\n.\n\n\n\n\nRetrieving and installing CALCEPH.jl\n\n\nIn your favorite Julia interpreter, run:\n\n\nPkg.clone(\nhttps://github.com/bgodard/CALCEPH.jl\n)\n\n\n\n\nTo start using it:\n\n\nusing CALCEPH", 
            "title": "Install"
        }, 
        {
            "location": "/install/#prerequisites", 
            "text": "", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/install/#linux-and-os-x", 
            "text": "If you do not have the  CALCEPH C library  installed, the installation process will fetch it and try to build it, in which case you need a working C compiler.", 
            "title": "Linux and OS X"
        }, 
        {
            "location": "/install/#windows", 
            "text": "Install first the  CALCEPH C library .", 
            "title": "Windows"
        }, 
        {
            "location": "/install/#retrieving-and-installing-calcephjl", 
            "text": "In your favorite Julia interpreter, run:  Pkg.clone( https://github.com/bgodard/CALCEPH.jl )  To start using it:  using CALCEPH", 
            "title": "Retrieving and installing CALCEPH.jl"
        }, 
        {
            "location": "/context/", 
            "text": "#\n\n\nCALCEPH.CalcephEphem\n \n \nType\n.\n\n\nCalcephEphem\n\n\n\n\nEphemeris descriptor. Create with:\n\n\neph = CalCephEphem(filename)\neph = CalCephEphem([filename1,filename2...])\n\n\n\n\nThe ephemeris descriptor will be used to access the ephemeris and related   data stored in the specified files.\n\n\nBecause, Julia GC is lazy, you may want to free the memory managed by eph   before you get rid of the reference to eph with:\n\n\nfinalize(eph)\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephPrefetch\n \n \nFunction\n.\n\n\nCalcephPrefetch(eph)\n\n\n\n\nThis function prefetches to the main memory all files associated to the ephemeris descriptor eph.\n\n\nsource", 
            "title": "Ephemeris context"
        }, 
        {
            "location": "/units/", 
            "text": "#\n\n\nCALCEPH.CalcephUnitAU\n \n \nConstant\n.\n\n\nCalcephUnitAU\n\n\n\n\nAstronomical Unit: distance unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephUnitKM\n \n \nConstant\n.\n\n\nCalcephUnitKM\n\n\n\n\nkilometer: distance unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephUnitDay\n \n \nConstant\n.\n\n\nCalcephUnitDay\n\n\n\n\nday: time unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephUnitSec\n \n \nConstant\n.\n\n\nCalcephUnitSec\n\n\n\n\nsecond: time unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephUnitRad\n \n \nConstant\n.\n\n\nCalcephUnitRad\n\n\n\n\nradian: angle unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephUseNaifId\n \n \nConstant\n.\n\n\nCalcephUseNaifId\n\n\n\n\nhas to be added to the unit argument when using NAIF integer codes for identification of center and target\n\n\nsource", 
            "title": "Units"
        }, 
        {
            "location": "/ids/", 
            "text": "#\n\n\nCALCEPH.BodyId\n \n \nType\n.\n\n\nBodyId\n\n\n\n\nBody identifiers.\n\n\nsource\n\n\n#\n\n\nCALCEPH.add!\n \n \nFunction\n.\n\n\nadd!(bid,name,id)\n\n\n\n\nAdd a new mapping name-\nid into BodyId instance bid.\n\n\nExample:\n\n\nbid=CALCEPH.BodyId()\nadd!(bid,:tatooine,1)\nadd!(bid,:dagobah,2)\nadd!(bid,:Dagobah,2)\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.loadData!\n \n \nFunction\n.\n\n\nloadData!(bid,filename)\n\n\n\n\nLoad mapping (body name,body ID) from file into BodyId instance bid.\n\n\nExample file \nhttps://github.com/bgodard/CALCEPH.jl/blob/master/data/NaifIds.txt\n\n\nsource\n\n\n#\n\n\nCALCEPH.NaifId\n \n \nConstant\n.\n\n\nNaifId\n\n\n\n\nNAIF identification numbers\n\n\nExamples:\n\n\n\n\nNaifId.id[:sun]-\n10\n\n\nNaifId.id[:mars]-\n499\n\n\nNaifId.names[0]-\nSet(Symbol[:ssb, :solar_system_barycenter])\n\n\n\n\nsource", 
            "title": "Identifiers"
        }, 
        {
            "location": "/compute/", 
            "text": "#\n\n\nCALCEPH.CalcephCompute\n \n \nFunction\n.\n\n\nCalcephCompute(eph,JD0,time,target,center)\n\n\n\n\nCompute position and velocity of target with respect to center at epoch JD0+time. This routine does not support the NAIF numbering scheme. For the NAIF numbering scheme, use CalcephComputeUnit or CalcephComputeOrder, with passing CalcephUseNaifId in the unit argument. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument JD0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and JD0, the desired time, if you don't take care about precision.\n\n\nOutput units are:\n\n\n\n\nAU and AU/day for position and velocity\n\n\nrad and rad/day for librations\n\n\nsecond and unitless for time ephemeris and time ephemeris rate\n\n\n\n\nArguments\n\n\n\n\nJD0::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body or reference point whose coordinates are required.\n\n\ncenter::Int\n: The origin of the coordinate system.\n\n\n\n\nThe possible values for target and center are :\n\n\n\n\n1 : Mercury Barycenter\n\n\n2 : Venus Barycenter\n\n\n3 : Earth\n\n\n4 : Mars Barycenter\n\n\n5 : Jupiter Barycenter\n\n\n6 : Saturn Barycenter\n\n\n7 : Uranus Barycenter\n\n\n8 : Neptune Barycenter\n\n\n9 : Pluto Barycenter\n\n\n10    : Moon\n\n\n11    : Sun\n\n\n12    : Solar Sytem barycenter\n\n\n13    : Earth-moon barycenter\n\n\n15    : Librations\n\n\n16    : TT-TDB\n\n\n17    : TCG-TCB\n\n\nasteroid number + CALCEPH_ASTEROID    : asteroid\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephComputeUnit\n \n \nFunction\n.\n\n\nCalcephComputeUnit(eph,JD0,time,target,center,unit)\n\n\n\n\nCompute position and velocity of target with respect to center at epoch JD0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument JD0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and JD0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\nJD0::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body or reference point whose coordinates are required. The numbering system depends on the parameter unit.\n\n\ncenter::Int\n: The origin of the coordinate system. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (CalcephUnit*) and/or the constant CalcephUseNaifId. If the unit contains CalcephUseNaifId, the NAIF identification numbering system is used for the target and the center (see module NaifId). If the unit does not contain CalcephUseNaifId, the old number system is used for the target and the center (see the list in the documentation of function CalcephCompute).\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephComputeOrder\n \n \nFunction\n.\n\n\nCalcephComputeOrder(eph,JD0,time,target,center,unit,order)\n\n\n\n\nCompute position and derivatives up to order of target with respect to center at epoch JD0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument JD0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and JD0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\nJD0::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body or reference point whose coordinates are required. The numbering system depends on the parameter unit.\n\n\ncenter::Int\n: The origin of the coordinate system. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (CalcephUnit*) and/or the constant CalcephUseNaifId. If the unit contains CalcephUseNaifId, the NAIF identification numbering system is used for the target and the center (see module NaifId). If the unit does not contain CalcephUseNaifId, the old number system is used for the target and the center (see the list in the documentation of function CalcephCompute).\n\n\n\n\norder::Int\n : The order of derivatives\n\n\n\n\n0: only the position is computed.\n\n\n1: only the position and velocity are computed.\n\n\n2: only the position, velocity and acceleration are computed.\n\n\n3: the position, velocity and acceleration and jerk are computed.\n\n\n\n\n\n\n\n\nIf order equals to 1, the behavior of CalcephComputeOrder is the same as that of CalcephComputeUnit.\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephOrientUnit\n \n \nFunction\n.\n\n\nCalcephOrientUnit(eph,JD0,time,target,unit)\n\n\n\n\nCompute Euler angles and first derivative for the orientation of target at epoch JD0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument JD0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and JD0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\nJD0::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body or reference point whose orientation is required. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (CalcephUnit*) and/or the constant CalcephUseNaifId. If the unit contains CalcephUseNaifId, the NAIF identification numbering system is used for the target and the center (see module NaifId). If the unit does not contain CalcephUseNaifId, the old number system is used for the target and the center (see the list in the documentation of function CalcephCompute). The angles are expressed in radians if unit contains CalcephUnitRad.\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.CalcephOrientOrder\n \n \nFunction\n.\n\n\nCalcephOrientOrder(eph,JD0,time,target,unit,order)\n\n\n\n\nCompute Euler angles and derivatives up to order for the orientation of target at epoch JD0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument JD0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and JD0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\nJD0::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: JD0+time must be equal to the Julian date for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body or reference point whose orientation is required. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (CalcephUnit*) and/or the constant CalcephUseNaifId. If the unit contains CalcephUseNaifId, the NAIF identification numbering system is used for the target and the center (see module NaifId). If the unit does not contain CalcephUseNaifId, the old number system is used for the target and the center (see the list in the documentation of function CalcephCompute).\n\n\n\n\norder::Int\n : The order of derivatives\n\n\n\n\n0: only the angles are computed.\n\n\n1: only the angles and 1st derivatives are computed.\n\n\n2: only the angles, the 1st derivatives and 2nd derivatives are computed.\n\n\n3: the angles, the 1st derivatives, 2nd derivatives and 3rd derivatives are computed.\n\n\n\n\n\n\n\n\nIf order equals to 1, the behavior of CalcephOrientOrder is the same as that of CalcephOrientUnit.\n\n\nsource", 
            "title": "Ephemeris computation"
        }, 
        {
            "location": "/constants/", 
            "text": "#\n\n\nCALCEPH.CalcephConstants\n \n \nFunction\n.\n\n\nCalcephConstants(eph)\n\n\nRetrieve the constants stored in the ephemeris associated to handle eph as a dictionary\n\n\nsource", 
            "title": "Ephemeris constants"
        }, 
        {
            "location": "/utilities/", 
            "text": "#\n\n\nCALCEPH.FivePointStencil\n \n \nFunction\n.\n\n\nFivePointStencil(f,x,n::Integer,h)\n\n\n\n\nEvaluates function f and its derivatives up to order n \u2208 [0,4] at x: $f(x),f'(x),...,f^{(n)}(x)$ The result is an array of length n+1. Derivatives are numerically computed using the 5-point stencil method with h\u22600 being the grid spacing: \nhttps://en.wikipedia.org/wiki/Five-point_stencil\n\n\nsource", 
            "title": "Utilities"
        }
    ]
}